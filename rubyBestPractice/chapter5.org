* 関数型プログラミングのテクニック
Rubyにおおける状態は、すべて可変。だから完全に関数型プログラミング言語ではない。
Rubyはオブジェクト指向言語なので、状態をなくすのでなく、状態を管理するところに注目する。
** 怠惰は美徳(lazy.rb)

** 可変状態を最小限にして、副作用を減らす
配列
元の配列を変更するのではなく、新しい配列を作ることが、副作用のないコード。

*** まとめ
- Rubyにおいて、副作用を避ける方法は、元のオブジェクトをイテレートしながら、必要な状態変換を実行して、新しいオブジェクトにその状態を入れること。
- Array#+ のように、操作を実行するたびに新しいオブジェクトをつくると、ステートレスなコードを書くことができる。
- 再帰的な解決策は、シンプルでステートレスにはなるが、パフォーマンスのペナルティになるおそれがある。
- オブジェクトをたくさんつくっても、パフォーマンス問題を引き起こすおそれがある。

** メモ化
入力に基づいて、関数の戻値をキャッシュする(メモ化)すると、パフォーマンスを向上させることができる。(メモリを圧迫しないかぎり)

*** まとめ
関数が、1つの入力から常に同じ出力が得られる(well-defined)場合、メモ化によってキャッシュできる。
メモ化はCPU時間をメモリに交換すること。メモリのコストが安くて、CPU時間のコストが高いときに使う。
解決策を自作するとき、Hash.newのブロック形式をつかうと、シンプルなキャッシュオブジェクトを手軽に作れる。

** 無限リスト
[[file:ch5/inifinite_list.rb]] では、外部で行われるイテレーションと状態変換を内部でおこなっている。

*** まとめ
- 無限リストは、1つの値と、その値を次の要素に変換するような手続きの両方を持つノードによって構成される
- 無限リストは遅延評価されるため、遅延ストリームと呼ばれることがある
- 無限リストが適しているのは、まとめてシーケンシャルなリストをイテレートする必要のあるとき、あるいはパラメータで調整できる汎用的な関数があるとき
- データがまばらなら、無限リストより、メモ化のほうが適しているかも
- 要素から要素への明確な関係がある長い要素列に対して、フィルタリングや状態変換しなければならないときは遅延ストリームをつかうとよい。

** 高階手続き
Rubyでは、 Proc もオブジェクトにすぎない。だからコードをまるで値であるかのように扱うことができる。
高階関数とは、その関数が入力として別の関数を受け付けるか、出力として関数を返すような関数のこと。
*** Symbol#to_procの説明
: class Symbol
:   def to_proc
:     lambda {|x| x.send(self)}
:   end
: end
そこで
: %w[foo bar baz].map(&:capitalize)
をつかうと
: lambda {|x| x.send(:capitalize)}
が呼び出され、
: %w[foo bar baz].map {|x| x.capitalize}
となる。
*** Symbol#to_procでつくるフィルタ
上のしくみを応用すると、簡単にフィルタがつくれる。
[[file:ch5/proc_filter.rb]]
